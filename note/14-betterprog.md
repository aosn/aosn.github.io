---
layout: subpage
title: 読書ノート - ベタープログラマ
---

[ベタープログラマ](/workshop/14-betterprog)の読書ノートです。

## 正誤表

- [『ベタープログラマ』正誤表](http://www001.upp.so-net.ne.jp/yshibata/#ERRATA)

## ノート

### 第1章

* **P3** 質問4の答えは難しい。
  * 優れた人でも一人でカッとなって作ったコードは優れてないかもしれない
  * そもそも優れたプログラマとは
  * クソコードだけど生産性高い人とかたまにいる
  * 2000行ある switch 文とか、region で頑張る C# コードとか

### 第2章

* **P8** この章は[リーダブルコード](/workshop/4-readablecode/)感
* **P16** 質問5は結論を出す質問じゃなくて戦争を勃発させたいだけの質問って感じ
  * Java だったらどうする？ → 全員スペースとの回答
  * Python の `pep8` とか Go の `gofmt` や Rust の `rustfmt` とかは偉大
* **P17** 折句のコード、never do this (笑)

### 第3章

* **P20** たるんだロジックは今の IDE ならだいたい見つけてくれる
  * モダンな IDE を使おう
  * JavaScript なら linter ちゃんといれよう
  * Pre-commit hook や CI も
* **P23** 共通化は依存関係を生むが、それに対して「責任を持ってコードに DRY を行ってください」だけはちょっと投げやり感
* **P25** デッドコードも IDE でだいたいわかる
  * テストコードが参照している気づかなかったり・・・
  * 参照調べてテストコードだけだったら消す等の綿密な調査が必要
  * 動的型付けだとわからないことも多い
  * 静的型付け言語もリフレクション使われると気づけない
* **P30** Q1、例えば null チェックを省いている理由とかはコードには現れない
  * assert やドキュメンテーションコメント等で示したい
* **P30** Q2 3 項演算子は使っていこう
  * でもネストはやめよう
  * 必要によっては説明変数を置こう (リーダブルコードにあるように)
  * Go には 3 項演算子ないけどね・・・
* **P30** Q3 共通な部分だけ関数にくくり出すとか
* **P30** Q5 チームで開発したり API として公開するときは有益かと
  * ただメンテしづらいアスキーアートはやめよう

### 第4章

* **P33** YAGNI 違反、最初にコードを書き始めるときには結構やっちゃうかも
* **P37** 機能追加したついでにおまけリファクタリングしちゃうことあるよね
  * diff が汚くなるし
  * test 落ちるとか conflict とかの可能性も増える
  * いつリファクタリングするのか結構悩ましい
  * 「年末」の大掃除は実践してみたいかも
  * 年末は比喩表現かも、実際は仕事が一区切りついたところとかかな

### 第5章

* **P42** [リーダブルコード](/note/4-readablecode/) でも同じ話した
* **P45** C++ で `#define` はやめよう

### 第6章

* **P58** Rails は見えないものが多すぎてチーム開発つらい
  * "「Ruby そのものが自由すぎる」だとか、「他人の書いた Rails コードを読みたくない」だとかいう批判をよく聞くけど、そういった声は基本的に5人以上 で Rails を触ってしまった場合に起きる問題である。" (参考: [Ruby on Rails の魅力と思想 - ボクココ](http://www.bokukoko.info/entry/2018/03/28/221026))

### 第7章

* **P62** とんでもない汚物にはふたをしてしまうな :innocent:
  * 無理に保守するよりスクラップしてしまいたい
  * 式年遷宮とか、いまやIT用語だね
  * EOL で強制的に発動するやつも
  * P64 に繋がる

### 第8章

* **P72** 質問
  * `malloc` の戻り値、チェックしてますか？ (参考: [MEM32-C. メモリ割り当てエラーを検出し、対処する](https://www.jpcert.or.jp/sc-rules/c-mem32-c.html))
  * [awesome go linters](https://github.com/golangci/awesome-go-linters) ええで
　
### 第9章

* プログラマーは予期しないことを無視しがち.予期しないことを予期しましょう
* エラーについて
* 防衛的プログラミングでエラーをつぶす
* 車の場合　ビットが熱・ノイズで反転する可能性があるのでRAMを毎周期リフレッシュする
  * -> 発生確率考えてないと無駄なことになってそう
  * -> RAM変数が書き変わってる可能性を考慮しつつ

* web系だと、エラー処理のコードが少ない
  * -> バグってもそんなに問題にならない、厳密に動くことを要求されない
  * -> リリース速度優先　
  * -> アプリ関係も多いかも　
  * -> UIが悪いとすく使われなくなっちゃうから微妙

* スレッド
  * スレッドモデル自体がバグの温床
  * スレッドプーリングでスレッド枯渇して速度低下
  * スレッドを直接触らない(ライブラリに投げる)


* この話の教訓
  * 問題にならないと想定していた事が現実に起こってしまうことがままある
  * 正常系->異常系の流れで書いてしまうので、エラー処理がを想定する
 
* 質問
  * 4  人間　お金　締切　QCD
  * 2 質問という名の忠告ですよね。。
  * 3 厳格なエラー処理をしないと最終的に自分の首しまる。。。
  * 3 関わる人が少ないコード

### 第10章

* 質問
  * 1: ドハマリするデバックは時間かかえるよね・・・
  * 2: だいたい後者かな・・・
  * 3: 変わる、調査しないといけないスコープを狭められる
  * Red Green Refactor の枠組みでテスト強度をどうあげていくか (やや脱線)
  * 1回を濃くするか、何回も回すかなどいくつかのアプローチがありそう
  * 4: 許容できるバグの数、結局はビジネス的な天秤かなという気がする

### 第11章

* **P97** 皮下テスト (subcutaneous test) って初めて聞いた
  * Martin Fowler が解説している (参考: [SubcutaneousTest](https://martinfowler.com/bliki/SubcutaneousTest.html))
  * 元は医療用語っぽい感じがする

* **P96** インテグレーションテストの単位は？
  * 別コンポーネントだったり別チームだったりあるいはその両方
  * Web アプリだとフロントエンドーバックエンドとか

* **P97** テスト駆動とテストファーストは違うというお話

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">情報処理試験にテスト駆動開発が出題されたらしいけど、問題文はこれだろうか。正解は「エ」なのだろうけど、なんというか、ソウジャナイ感があるな……（テストファーストの説明だったらこれでも良いのだけど） <a href="https://t.co/wCKKoSFUM5">https://t.co/wCKKoSFUM5</a></p>&mdash; Takuto Wada (@t_wada) <a href="https://twitter.com/t_wada/status/986055492785991680?ref_src=twsrc%5Etfw">2018年4月17日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

* **P100** カバレッジ 75.0% いかないとリリースできない Salesforce とか

* **P101** 無意味に環境に依存するテストはつらい
  * OS やランタイムの時計操作するとか・・・
  * ファイルシステム依存とか・・・

* **P102** この Java コードは JUnit なのか TestNG なのか... (`assertEquals` の引数 (expected, actual) が両者で逆なので)

* **P106** モックマニアいるよね〜

### 第12章

* **P115** 「分散した自己」 (distributed self) が初耳だった
  * Michel Feathers は「レガシーコード改善ガイド」の著者、ただしその本には出てこないような
  * Twitter だった・・・！

<blockquote class="twitter-tweet" data-lang="ja"><p lang="en" dir="ltr">Distributed Self - the pattern where a god class passes itself to a bunch of instances it creates.</p>&mdash; Michael Feathers (@mfeathers) <a href="https://twitter.com/mfeathers/status/63287091487973376?ref_src=twsrc%5Etfw">2011年4月27日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

* **P116** Singleton は不変 (immutable) でも悪なのか？
  * 少なくとも複雑さについて言えば、実質的なグローバル変数みたいな使い方が悪なけでは
  * Scala, Kotlin の companion object は実質シングルトンになるが、普通状態を持つような使い方はしない
  * そもそも普通のクラスでも `HogeHogeConsts` みたいな定数を集めていろんな所から参照するのも複雑さを持ち込む

### 第13章

* **P119** この章、アジャイルソフトウェア開発の奥義に似てる感じがする
  - 人間とか組織の話はストーリー仕立てのほうがわかりやすいとは思う
* **P128** ペアプロだけでアーキテクチャ・設計の品質を保てるか、というのはある。それ以外はコードレビューや設計レビューといっても、適切なレビュアーがいないとやはり品質を保てるのかわからない。
* **P131** 設計のための時間、大事だなぁ。長すぎるとオーバーエンジニアリングしてしまう。セカンドシステム症候群とも絡む。
* **P133** 限られた時間で仕事をこなすのが役割な我らからすると、あれもやるべき、これもやるべきといった話だけだと綺麗事な感じがする。トレードオフなはず。
* **P132** 「設計上の決定を、決定するためのすべての情報をわかっている適切な時期に行う。まだ行えない設計に関する決定を遅らせましょう。」これは現実問題相当きびしいのでは・・・ :innocent:
