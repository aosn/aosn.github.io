---
layout: subpage
title: 読書ノート - ベタープログラマ
---

[ベタープログラマ](/workshop/14-betterprog)の読書ノートです。

## 正誤表

- [『ベタープログラマ』正誤表](http://www001.upp.so-net.ne.jp/yshibata/#ERRATA)

## ノート

### 第1章

* **P3** 質問4の答えは難しい。
  * 優れた人でも一人でカッとなって作ったコードは優れてないかもしれない
  * そもそも優れたプログラマとは
  * クソコードだけど生産性高い人とかたまにいる
  * 2000行ある switch 文とか、region で頑張る C# コードとか

### 第2章

* **P8** この章は[リーダブルコード](/workshop/4-readablecode/)感
* **P16** 質問5は結論を出す質問じゃなくて戦争を勃発させたいだけの質問って感じ
  * Java だったらどうする？ → 全員スペースとの回答
  * Python の `pep8` とか Go の `gofmt` や Rust の `rustfmt` とかは偉大
* **P17** 折句のコード、never do this (笑)

### 第3章

* **P20** たるんだロジックは今の IDE ならだいたい見つけてくれる
  * モダンな IDE を使おう
  * JavaScript なら linter ちゃんといれよう
  * Pre-commit hook や CI も
* **P23** 共通化は依存関係を生むが、それに対して「責任を持ってコードに DRY を行ってください」だけはちょっと投げやり感
* **P25** デッドコードも IDE でだいたいわかる
  * テストコードが参照している気づかなかったり・・・
  * 参照調べてテストコードだけだったら消す等の綿密な調査が必要
  * 動的型付けだとわからないことも多い
  * 静的型付け言語もリフレクション使われると気づけない
* **P30** Q1、例えば null チェックを省いている理由とかはコードには現れない
  * assert やドキュメンテーションコメント等で示したい
* **P30** Q2 3 項演算子は使っていこう
  * でもネストはやめよう
  * 必要によっては説明変数を置こう (リーダブルコードにあるように)
  * Go には 3 項演算子ないけどね・・・
* **P30** Q3 共通な部分だけ関数にくくり出すとか
* **P30** Q5 チームで開発したり API として公開するときは有益かと
  * ただメンテしづらいアスキーアートはやめよう

### 第4章

* **P33** YAGNI 違反、最初にコードを書き始めるときには結構やっちゃうかも
* **P37** 機能追加したついでにおまけリファクタリングしちゃうことあるよね
  * diff が汚くなるし
  * test 落ちるとか conflict とかの可能性も増える
  * いつリファクタリングするのか結構悩ましい
  * 「年末」の大掃除は実践してみたいかも
  * 年末は比喩表現かも、実際は仕事が一区切りついたところとかかな

### 第5章

* **P42** [リーダブルコード](/note/4-readablecode/) でも同じ話した
* **P45** C++ で `#define` はやめよう

### 第6章

* **P58** Rails は見えないものが多すぎてチーム開発つらい
  * "「Ruby そのものが自由すぎる」だとか、「他人の書いた Rails コードを読みたくない」だとかいう批判をよく聞くけど、そういった声は基本的に5人以上 で Rails を触ってしまった場合に起きる問題である。" (参考: [Ruby on Rails の魅力と思想 - ボクココ](http://www.bokukoko.info/entry/2018/03/28/221026))

### 第7章

* **P62** とんでもない汚物にはふたをしてしまうな :innocent:
  * 無理に保守するよりスクラップしてしまいたい
  * 式年遷宮とか、いまやIT用語だね
  * EOL で強制的に発動するやつも
  * P64 に繋がる

### 第8章

* **P72** 質問
  * `malloc` の戻り値、チェックしてますか？ (参考: [MEM32-C. メモリ割り当てエラーを検出し、対処する](https://www.jpcert.or.jp/sc-rules/c-mem32-c.html))
  * [awesome go linters](https://github.com/golangci/awesome-go-linters) ええで
　
### 第9章

* プログラマーは予期しないことを無視しがち.予期しないことを予期しましょう
* エラーについて
* 防衛的プログラミングでエラーをつぶす
* 車の場合　ビットが熱・ノイズで反転する可能性があるのでRAMを毎周期リフレッシュする
  * -> 発生確率考えてないと無駄なことになってそう
  * -> RAM変数が書き変わってる可能性を考慮しつつ

* web系だと、エラー処理のコードが少ない
  * -> バグってもそんなに問題にならない、厳密に動くことを要求されない
  * -> リリース速度優先　
  * -> アプリ関係も多いかも　
  * -> UIが悪いとすく使われなくなっちゃうから微妙

* スレッド
  * スレッドモデル自体がバグの温床
  * スレッドプーリングでスレッド枯渇して速度低下
  * スレッドを直接触らない(ライブラリに投げる)


* この話の教訓
  * 問題にならないと想定していた事が現実に起こってしまうことがままある
  * 正常系->異常系の流れで書いてしまうので、エラー処理がを想定する
 
* 質問
  * 4  人間　お金　締切　QCD
  * 2 質問という名の忠告ですよね。。
  * 3 厳格なエラー処理をしないと最終的に自分の首しまる。。。
  * 3 関わる人が少ないコード

### 第10章

* 質問
  * 1: ドハマリするデバックは時間かかえるよね・・・
  * 2: だいたい後者かな・・・
  * 3: 変わる、調査しないといけないスコープを狭められる
  * Red Green Refactor の枠組みでテスト強度をどうあげていくか (やや脱線)
  * 1回を濃くするか、何回も回すかなどいくつかのアプローチがありそう
  * 4: 許容できるバグの数、結局はビジネス的な天秤かなという気がする
