---
layout: subpage
title: 読書ノート - 現場で役立つシステム設計の原則
---

[現場で役立つシステム設計の原則](/workshop/12-principles)の読書ノートです。

## 正誤表

- [サポートページ：現場で役立つシステム設計の原則 〜変更を楽で安全にするオブジェクト指向の実践技法：｜技術評論社](http://gihyo.jp/book/2017/978-4-7741-9087-7/support)

## ノート

### 第1章

* **P24** リーダブルコードにもあるが、数値を定義するときは単位を含めたほうがベター (金額だったら円なのか銭なのかドルなのか)
* **P24** セミコロンの前のスペースとか if の条件式の前後のスペースとか一貫性のないスタイリングがすごい気になる
* **P24** `shippingCost()` に `// 送料を算出する` とコメントが添えられているが、こんなわかりきったコメントいらないのでは (Javadoc ならまだしも)
* **P30** 定数定義の書き方がここと P24 で違う (大文字スネークケース対キャメルケース)
* 値オブジェクト、こんなにオブジェクト作ったらパフォーマンスインパクトありそう
  * ドメイン駆動設計を実践する上では不可欠だが、ボトルネックになるならば分析した上でチューニングしたい
  * サーバーサイドなら札束で殴ればいいけど、組み込みでは限界ある
  * ファーストクラスコレクションのほうはオブジェクト数は +1 するだけなのでパフォーマンスインパクトはほとんどない
  * 値オブジェクトで DB (ORM) 絡むときは DB の型と値オブジェクトの相互変換のためのコンバーターを書く必要があり、ボイラープレート的に変換コードをゴリゴリ実装する必要がある

### 第2章

* **P51** 早期リターン、[リーダブルコード](/note/4-readablecode)を読んだときも同じ議論をしたね
  * Scala ではそもそも非推奨とか。
  * return 1個主義派の主張: Excel でフローチャートが書きやすい :innocent:
* **P53** 網羅性、相互独立性がコードから検査できないのがこのパターンの怖いところ
* **P57** なんでセミコロンがあったりなかったりするのか？誤植？
* **P65** `EnumSet.of` は使ってるのに `EnumMap` は使わないんだ・・・
* **P66** Enum のアプローチも良いけど最近の Better Java 系などの言語だと網羅性検査がある型のパターンマッチで済ませることも
  * Go の type switch は網羅性チェックない・・・
  * Java だと `instanceof` は良くないものという認識があるが、C# とかだと動的型も部分的に持ち込こまれているのでナチュラルにやることがある

### 第3章

* **P68** ORマッパー使ってるとデータクラス量産してしまいやすい
  * ドメインモデル貧血症のことだね
  * Lombok とか使ってナチュラルにデータクラスを量産してしまうシステムをよく見る
* **P73** [GopherCon 2017 の Anti-patterns](https://github.com/gophercon/2017-talks/blob/master/EdwardMuller-GoAntipatterns/GoAntipatterns.pdf) (33スライド目) でも同じ話題あったような
  * StringUtils 的な業務ロジック・ドメインと関係ないものなら util 合ってもいいような気もするけど、いろんなライブラリがこの名前で実装しててなんだかなぁとも思う
  *  util とか common とかあると困ったらここに突っ込んでしまう、肥溜め化する
* **P81** ドメインオブジェクト用のユーティリティメソッド (インスタンス変数はさわらない) は無理に移動せずそのまま static メソッドでぶらさげても良いのでは？
  * Customer 用に Customers クラス作って static メソッドおくとかやらない？
  * この本だと複数形はファーストクラスコレクションに付ける名前って感じ
* **P82** でかすぎる API は使うのもつらいよね
  * RxJava の [Observable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html) とか [Flowable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html) とか

### 第4章

* **P94** 本当に重複なくなるの!?
  * 継承とか使いまくって重複とか見かけ上消えてもあんまりうれしくないんだよね
  * 日本語の業務ロジック、無理やり英語に直訳したせいでどこに何か書いてあるのかわからなくなったりすることもある。ユビキタス言語的にちゃんと定義するか、あとは日本語のままプログラミングするとかしないとね
* **P107** パッケージ図の依存関係、DI 使うとある程度変えることもできたりするね
* **P121** こういったバリデーション系は C# の Attribute や Java の Annotation 使っていい感じにできるよって ThoughtWorks アンソロジーに書いてあった
* **P123** 「ちょっとした if 文の追加は (中略) まちがった方向です」とあるが、数値の比較とかバリデーションとかの if 文まで NG といっている？過激な主張な気がする
* **P129** `ok` あるんだし `ng` いらないと思う、API が冗長
* **P129** Java 8 の `Optional` 紹介するんなら、コード中の for 文を `Stream#anyMatch` 使うぐらいはやってほしい
* **P137** ようはコミュ力の話だね

### 第5章

* **P150** この図で言うと、ドメインモデルはデータソースを触れない
* **P150** この図は Spring Framework に振りすぎている気がする、他のフレームワークだとこはならなかったりする
* **P152** `@Autowired` のフィールドインジェクションは非推奨、コンストラクタの引数で注入する
* **P160** 登録参照を分けるスタイルは CQRS と呼ばれる
* **P164** ここで言うシナリオはサービスでよいが、CQRS 的なのはリポジトリでやることじゃないかな
* **P165** 「契約による設計」と「防御的プログラミング」の双方に違和感。Twitter でディスカッション

柴田さんからのコメント:

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">確かに「契約による設計」と「防御的プログラミング」の両方を勘違いしている説明になっていますね。不正な値や不正な呼び出し順序に対する振る舞いもきちんと「契約として設計」し、その契約を守った呼び出しであるかを防御的にプログラミングしないと、無駄なデバッグ工数が発生するだけですからね。</p>&mdash; Yoshiki Shibata/柴田芳樹 (@yoshiki_shibata) <a href="https://twitter.com/yoshiki_shibata/status/955000080213319680?ref_src=twsrc%5Etfw">2018年1月21日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

対する著者の反論:

<blockquote class="twitter-tweet" data-conversation="none" data-cards="hidden" data-lang="ja"><p lang="ja" dir="ltr">メイヤーは、呼び出す側が必ず契約を守ることを前提にしてコードを書くスタイルを重視して、それを契約による設計と名付けたと思います。契約の表明は実行用のコードとは別にすべきだと。<br>私の理解はこの回答に近いですね。<a href="https://t.co/XEKToVvMcb">https://t.co/XEKToVvMcb</a><br>本でうまく説明できていないかもしれませんが。</p>&mdash; 増田 亨． (@masuda220) <a href="https://twitter.com/masuda220/status/955029452894830592?ref_src=twsrc%5Etfw">2018年1月21日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

### 第6章

- **P174** データベースが複雑だとプログラムも複雑になるってホント？
  - オブジェクト構造にデータベースを合わせれば、そうはならないのでは
  - ひどいデータベース構造でプログラムが複雑になる例は体験したことがある
- **P179** NONNULL 全適用は本当に現実的？やりすぎなケースも一部あるんじゃないかなと
  - 人間の都合、イレギュラーなオペレーションで NULL が必要になったときとか (そのためだけにテーブルを作るのか)
- **P187** たいていの DB は UPSERT イディオムがあるので、ロジックのシンプル度は DELETE / INSERT のほうが悪いのでは
  - 記録系テーブルで UPDATE 使わないのはわかるが、残高テーブルは状態なので UPDATE 排除する論理がわからない
- **P187** 記録と残高の更新をトランザクションにしないと、同時に更新するときに不整合が発生するのでは
  - 非同期メッセージなら結果整合性保てるけど
  - 「要求にもよりますが」うまい逃げ方だな～
- **P194** JPAディスられている・・・
  - ドメインオブジェクトを一切汚さないために (JPA では不要な) SQL を書く犠牲をはらってることを忘れてはならない
- **P195** NoSQL の論点もほしいな・・・

### 第7章

- **P205** 図7-1, フッターのコピーライトにもモザイクれたほうが・・・ :innocent: SB Human Capital Corp は求人サイトの模様。競合調査かな？
- **P214** 文言とか class 属性とか、画面の変更にドメインオブジェクトが引っ張られて良くない。多言語対応も入れづらくなる
  - 画面毎に個別に重複コード用意するなとかいてあるが、そのごのセクションでは画面のHTMLタグに癒着したデータ構造や画面に出力する文字列をドメインオブジェクトの文字列にする言及がある
- **P217** 画面は画面、モデルはモデルでは
  - 並び順なんてプラットフォームによって変わることだってあるし
- **P219** 消えた `long id` とかはどうすんのさ
  - `Book` とは別に `BookSummary` 作れといっている？
